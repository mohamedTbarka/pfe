\chapter{Implementation}
\section{JBotSim: a Tool for Fast Prototyping of Distributed Algorithms in Dynamic Networks}
\paragraph{What's JBotSim ?}JBotSim is an open source simulation library that is dedicated to distributed algorithms in dynamic networks. I developed it with the purpose in mind to make it possible to implement an algorith- mic idea in minutes and interact with it while it is running (e.g., add, move, or delete nodes). Besides interaction, JB OT S IM can also be used to prepare live demos of an algorithm and to show it to colleagues or students, as well as to assess the algorithm per- formance. JB OT S IM is not a competitor of mainstream simulators such as NS3 [5], OMNet [10], or The One [8], in the sense that it does not aim to implement real-world networking protocols. Quite the opposite, JB OT S IM aims to remain technology-insensitive and to be used at the algorithmic level, in a way closer in spirit to the ViSiDiA project (a general-purpose platform for distributed algo- rithms). Unlike ViSiDiA, however, JB OT S IM natively supports mobility and dynamic networks (as well as wireless communica- tion). Another major difference with the above tools is that it is a library rather than a software: its purpose is to be used in other pro- grams, whether these programs are simple scenarios of full-fledged software. Finally, JB OT S IM is distributed under the terms of the LGPL licence, which makes it easily extensible by the community.
\paragraph{}Whether the algorithms are centralized or distributed, the natu- ral way of programming in JB OT S IM is event-driven: algorithms are specified as subroutines to be executed when particular events occur (appearance or disappearance of a link, arrival of a message, clock pulse, etc.). Movements of the nodes can be controlled ei- ther by program or by means of live interaction with the mouse (adding, deleting, or moving nodes around with left-click, right- click, or drag and drop, respectively). These movements are typi- cally performed while the algorithm is running, in order to visualize it or test its behavior in challenging configurations.
\paragraph{}The present document offers a broad view of JB OT S IM’s main features and design traits. I start with preliminary information in
\paragraph{Practical Aspects}In this short section, I show how to install JB OT S IM and run it with a first basic example (this step is not required to keep reading the present document). I also provide links to online documentation and examples, for readers who would like to explore JB OT S IM’s features beyond this paper.
\subparagraph{Fetching JBOTSIM}The straightest (and safest) way to obtain JB OT S IM is to fetch the latest release, as a jar package on JB OT S IM’s website [1]. One can also get the latest development version from SourceForge’s GIT repository and compile it as shown below, keeping in mind that online documentation refers to the official release rather than this version. Here is the command: > git clone git://git.code.sf.net/p/jbotsim/git target where target is the local directory in which to put JB OT S IM. From that directory, one can produce the JAR package using a sim- ple make. After more than seven years of development, JB OT S IM is finally approaching version 1.0 (as of today, version 1.0-prealpha) and I think it is ready to be tested by the community.
\subparagraph{First steps}As a first program, one can copy the code from Listing 1 into a file named HelloWorld.java.


\begin{lstlisting} [caption=HelloWorld with JBOTSIM,captionpos=b]
import jbotsim.Topology;
import jbotsim.ui.JViewer;
public class HelloWorld{
	public static void main(String[] args){
		new JViewer(new Topology());
	} 
}
\end{lstlisting}

How to use the JAR file and run the HelloWorld example:
\begin{itemize}
	\item If using IntelliJ, go to Project structure > Modules (select the module) > Dependencies > "+" and add jbotsim.jar.
	\item If using Eclipse, go to Project > Properties > Java build path > Librairies > Add external jar and add jbotsim.jar.
	\item From the terminal, the following commands can be used: javac -cp jbotsim.jar HelloWorld.java (compilation) java -cp .:jbotsim.jar HelloWorld (execution)
\end{itemize}
\subparagraph{}By running the program, one should see an empty gray surface in which nodes can be added, moved, or deleted using the mouse.
\subparagraph{Sources of documentation}In this document, I provide a general overview of what JB OT S IM is and how it is designed. This is by no means a comprehensive pro- gramming manual. The reader who wants to explore further some features or develop complex programs with JB OT S IM is referred to the API documentation (see javadoc on the website). \subparagraph{}Examples can also be found on JB OT S IM’s website, together with comments and explanations. These examples offer a good starting point to learn specific components of the API from an op- erational standpoint – the present document essentially focuses on concepts. Most of the online examples feature embedded videos. Finally, most of the examples in this paper are also available on JB OT S IM’s website. Feel free to check them when the code given here is incomplete (e.g. I often omit package imports and main() methods for conciseness).
\paragraph{Features and Architecture}This section provides an overview of JB OT S IM’s key features and discusses the reason why some design choices were made. I review topics as varied as programming paradigms, clock schedul- ing, user interaction, and global architecture.
\newpage
\subparagraph{Basic features of nodes and links} 
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{fig_2}
	\caption[A highway scenario composed of vehicles, road-side units, and central servers. Part of the network is ad hoc (and wireless); the rest is infrastructured (and wired).]{A highway scenario composed of vehicles, road-side units, and central servers. Part of the network is ad hoc (and wireless); the rest is infrastructured (and wired).}
	\label{fig:fig2}
\end{figure}
\subparagraph{}JB OT S IM consists of a small number of classes, the most cen- tral being Node, Link, and Topology. The contexts in which dynamic networks apply are varied. In order to accommodate a majority of cases, these classes offer a number of conceptual varia- tions around the notions of nodes and links. Nodes may or may not possess wireless communication capabilities, sensing abilities, or self-mobility. They may differ in clock frequency, color, commu- nication range, or any other user-defined property. Links between the nodes account for potential communication among them. The nature of links varies as well; a link can be directed or undirected, as well as it can be wired or wireless – in the latter case JB OT S IM’s topology will update the set of links automatically, as a function of nodes distances and communication ranges.
\subparagraph{}JB OT S IM consists of a small number of classes, the most cen- tral being Node, Link, and Topology. The contexts in which dynamic networks apply are varied. In order to accommodate a majority of cases, these classes offer a number of conceptual varia- tions around the notions of nodes and links. Nodes may or may not possess wireless communication capabilities, sensing abilities, or self-mobility. They may differ in clock frequency, color, commu- nication range, or any other user-defined property. Links between the nodes account for potential communication among them. The nature of links varies as well; a link can be directed or undirected, as well as it can be wired or wireless – in the latter case JB OT S IM’s topology will update the set of links automatically, as a function of nodes distances and communication ranges.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{fig_3}
	\caption[A swarming scenario, whereby mobiles robots and UAVs collaborate in order to clean a public park.]{A swarming scenario, whereby mobiles robots and UAVs collaborate in order to clean a public park.}
	\label{fig:fig3}
\end{figure}
Figure 2 illustrates a purely ad hoc scenario, whereby a hetero- geneous swarm of UAVs and robots strives to clean a public park collectively. In this scenario, robots can detect and clean wastes of a certain type (red or blue) only if these are within their sens- ing range (depicted by a surrounding circle). However, they are pretty slow to move and cannot detect remote wastes. In the mean- time, a set of UAVs is patrolling over the park at higher speed and with larger sensing range. Whenever they detect a waste of some type, they store its position and start searching for a capable robot. In addition to sensing capabilities, UAVs can exchange messages with each other to optimize the process.
\subparagraph{}Besides nodes and links, the concept of topology is central in JB OT S IM. Topologies can be thought of as containers for nodes and links, together with dedicated operations like updating wireless links. They also play a central role in JB OT S IM’s event architec- ture, as explained later on.
\subparagraph{Distributed vs. centralized algorithms}
\subparagraph{}JB OT S IM supports the manipulation of centralized or distributed algorithms (possibly simultaneously). The natural way to imple- ment a distributed algorithm is by extending the Node class, in which the desired behavior is implemented. Centralized algorithms are not constrained to a particular model, they can take the form of any standard java class.
\subparagraph{Distributed algorithm}JB OT S IM comes with a default type of node that is implemented in the Node class. This class provides the most general features a node could have, including primitives for moving, exchanging messages, or tuning basic parameters (e.g. communication range and sensing range). Distributed algorithms are naturally imple- mented through adding specific features to this class. Listing 2 provides a basic example in which the nodes are endowed with self-mobility. The class relies on a key mechanism in JB OT S IM: performing periodic operations that are triggered by the pulse of the system clock. This is done by overriding the onClock() method, which is called periodically by JBotSim’s engine (by default, at every pulse of the clock). The rest of the code is responsible for moving the node, setting a random direction at construction time (in radian), then moving in this direction periodically. (More de- tails about the movement API can be found online.) Once this class is defined, new nodes of this type can be added to the topology in the same way as if they were of class Node, as il- lustrated in Listing 3. Here, a new topology is created first, then 10 nodes of the desired type (here, MovingNode) are added through the addNode() method at random locations (using -1 for x- coordinate or y-coordinate generates a random location for that co- ordinate; here both are random). In order to use MovingNode through the GUI, for instance when clicking with the mouse to add new nodes, this class must be registered as a node model. This is done by calling method setDefaultNodeModel() with the class itself as an argument, as shown on Listing 4. JB OT S IM will create new instances on the fly, using reflexivity. Several models can be registered simultaneously, using setNodeModel() with an additional argument that corresponds to the model name. If sev- eral models exist, JB OT S IM’s GUI (the viewer) displays a selec- tion list when a node is added by the user (in this example, only one model is set and it is used by default). In the scenario of Fig-ure 1, however, left-clicking on the surface would give the choice between car, tower, and server, the names of the three registered models for that scenario.
\begin{lstlisting} [caption=HelloWorld with JBOTSIM,captionpos=b]
import jbotsim.Node;
public class MovingNode extends Node{
	public MovingNode(){
		setDirection(Math.random() * 2*Math.PI);
	}
	public void onClock(){
		move(2);
	}
}
\end{lstlisting}

\begin{lstlisting} [caption=HelloWorld with JBOTSIM,captionpos=b]
public static void main(String[] args){ Topology tp = new Topology(400, 300); tp.setDefaultNodeModel(MovingNode.class); new JViewer(tp); }
\end{lstlisting}

\begin{lstlisting}
public static void main(String[] args){ Topology tp = new Topology(400, 300); tp.setDefaultNodeModel(MovingNode.class); new JViewer(tp); }
\end{lstlisting}


\subparagraph{Centralized algorithms}There are many reasons why a centralized algorithm can be pre- ferred over a distributed one. The object of study might be central- ized in itself (e.g. network optimization, scheduling, graph algo- rithms in general). It may also be simpler to simulate distributed things in a centralized way. Listing 5 implements such a version of the random waypoint mobility model, in which nodes repeat- edly move toward a randomly selected destination, called target. Unlike a distributed implementation, the movements of nodes are here driven by a global loop at every pulse of the clock. For each node, a target is created if it does not exists yet or if it has just been reached; then the node’s direction is set accordingly and the node is moved (by default, by 1 unit of distance). For convenience, the main() method is included in the same class. Notice the use of setProperty() and getProperty() in this example. These methods allow to store any object directly into a node, using a key/value scheme (where key is a string). Both Link and Topology objects offer the same feature.
\subparagraph{Architecture of the event system}
So far, we have seen one type of event: clock pulses, to be lis- tened to through the ClockListener interface. JB OT S IM offers a number of such events and interfaces, some of which become are ubiquitous. The main ones are depicted on Figure 3 on the fol- lowing page. This architecture allows one to specify dedicated op- erations in reaction to various events. For instance, one may ask to be notified whenever a link appears or disappears somewhere. Same for messages, which are typically listened to by the nodes themselves or can be watched at a global scale (e.g. to keep a log of all communications). In fact, every node is automatically noti- fied for its own events; it just needs to override the corresponding methods from the parent class Node in order to specify event han- dlings (e.g. onClock(), onMessage(), onLinkAdded(), onSensingIn(), onSelection(), etc.). Explicit listeners, on the other hand, like the ones in Figure 3, are meant to be used by centralized programs which do not extend class Node. Listing 6 gives one such example, consisting of a mobility trace recorder. This program listens to topological events of various kinds, including appearance or disappearance of nodes or links, and movements of the nodes. Upon each of these events, it outputs a string representation of the event using a dedicated human readable format called DGS [7]. Similar code could be written for Gephi [3]. Other events exist besides those represented in Figure 3, such as the SelectionListener interface, which makes it possible to be notified when a node is selected (middle-click) and make it initiate some tasks, for instance broadcast, distinguished role, etc.
\subparagraph{Single threading: why and how?}It seems convenient at first, to assign every node a dedicated thread, however JB OT S IM was designed differently. JB OT S IM is single-threaded, and definitely so. This section explains the why and the how. Understanding these aspects are instrumental in de- veloping well-organized and bug-free programs.
\begin{figure}[h!]
	\centering
	\includegraphics[width=1\linewidth]{fig_4}
	\caption[Main sources of events and corresponding interfaces in JB OT S IM.]{Main sources of events and corresponding interfaces in JB OT S IM.}
	\label{fig:fig4}
\end{figure}

\begin{lstlisting}
public class MyRecorder implements TopologyListener, ConnectivityListener, MovementListener{
	public MyRecorder(Topology tp){
		tp.addTopologyListener(this); tp.addConnectivityListener(this); tp.addMovementListener(this);
	}
	// TopologyListener public void onNodeAdded(Node node) { 	println("an " + node.hashCode() + " x:" + node.getX() + " y:" + node.getY()); } public void onNodeRemoved(Node node) { println("dn " + node.hashCode()); } // ConnectivityListener public void onLinkAdded(Link link) { println("ae " + link.hashCode() + " " + link.endpoint(0) + " " + link.endpoint(1)); } public void onLinkRemoved(Link link) { println("de " + link.hashCode()); } // MovementListener public void onNodeMoved(Node node) { println("cn " + node.hashCode() + " x:" + node.getX() + " y:" + node.getY()); } }
\end{lstlisting}