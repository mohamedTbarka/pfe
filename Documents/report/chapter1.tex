\chapter{Introduction}

Leader election is an important primitive for distributed computing, useful as a subroutine for any application that requires the selection of a unique processor among multiple candidate processors. Applications that need a leader range from the primary-backup approach to replication-based fault-tolerance to group communication systems [21], and from video conferencing to multi-player games [8].

In a dynamic network, communication links go up and down frequently. Wireless mobile networks are one example of dynamic networks, since node mobility changes the communication topology continuously. Even if nodes do not move, wireless communications are subject to more interference than in the wired case, but wired networks can also experience frequent topology changes. Recent research has focused on porting some of the applications mentioned above to dynamic networks, including wireless and sensor networks. For instance, Wang and Wu propose a replication-based scheme for data delivery in mobile and fault-prone sensor networks [24]. Thus there is a need for leader election algorithms that work in dynamic networks.

We consider the problem of ensuring that, if link changes cease, then eventually each connected component of the network has a unique leader (introduced as the “local leader election problem” in [5]). The algorithm in [10] is an extension of the leader election algorithm in [13], which in turn is an extension of the MANET routing algorithm TORA in [17]. TORA itself is based on ideas from [6]. Our cur- rent algorithm relaxes the requirement in [10] of nodes having perfect clocks and uses the concept of logical clocks instead.

Gafni and Bertsekas [6] present two routing algorithms based on the notion of link reversal. In these algorithms, each node maintains a height variable, drawn from a totally ordered set; the link between two nodes is considered to be directed from the endpoint with larger height to that with smaller height. Whenever a node becomes a sink, i.e., has no outgoing links, due to a link failure or due to notification of a neighbor’s changed height, the node increases its height so that at least one of its incoming links becomes outgoing. In one of the algorithms of [6], the height is a pair, while in the other the height is a triple; in both situations, heights are compared lexicographically and the least significant component is the node’s unique id.

The algorithms in [6] cause an infinite number of messages to be sent if a portion of the graph is disconnected from the destination. This drawback is overcome in TORA [17], through the addition of a clever mechanism by which nodes can identify that they have been partitioned from the destination. In this case, the nodes go into a quiescent state.

In TORA, each node maintains a 5-tuple of integers for its height, consisting of, from left to right, a 3 tuple called the reference level, a delta component, and the node’s unique id. The height tuple of each node is lexicographically compared to the tuple of each neighbor to impose a logical direction on links (higher tuple toward lower.)

The purpose of a non-zero reference level is to indicate when nodes have lost their path to the destination. Initially, the reference level is all zeroes. When a node loses its last outgoing link due to a link disappearing, it starts a new reference level by changing the first component of the triple to the current time, the second to its own id, and the third to 0, meaning that the search for the destination is started. Reference levels are propagated throughout a connected component, as nodes lose outgoing links, in a search for an alternate directed path to the destination. Propagation of reference levels is done using a mechanism by which a node increases its reference level when it becomes a sink; the delta value of the height is manipulated to ensure that links are oriented appropriately. If one section of the communication graph is a dead-end, then the third component of the reference level triple is set to 1. When this happens, the reference level is said to have been reflected, since it is subsequently propagated back toward the originator. If the originator receives reflected reference levels back from all its neighbors, then it has identified a partitioning from the destination.

The key observation in [13] is that TORA can be adapted for leader election: when a node detects that it has been partitioned from the destination (the old leader), then, in- stead of becoming quiescent, it elects itself. The information about the new leader is then propagated through the connected component. A sixth component was added to the height tuple to record the leader’s id.

However, when multiple topology changes occur, the algorithm in [13] can fail. In [10], a modification to the algorithm that works in an asynchronous system with arbitrary topology changes is presented. One new feature of this algorithm is to add a seventh component to the height: a timestamp associated with the leader id that records the time that the leader was elected. Also, a new rule by which nodes can choose new leaders is included. A newly elected leader initiates a “wave” algorithm [22]: when different leader ids collide at a node, the one with the most recent timestamp is chosen as the winner and the newly adopted height is further propagated. This strategy for breaking ties between competing leaders makes the algorithm compact and elegant, as messages sent between nodes carry only the height information of the sending node, and every message is identical in content.

Another contribution of [10] is a relatively brief, yet complete, proof of algorithm correctness. In addition to showing that each connected component eventually has a unique leader, it is shown that in certain well behaved situations, a new leader is not elected unnecessarily. The proof handles arbitrary asynchrony in the message delays.

In this paper, we relax the requirement in [10] that nodes have perfect clocks. Instead, we incorporate the idea of logical clocks, introduced in [11] into the already existing algorithm. In order to provide a way for logical clocks to be updated, we introduce a timestamp to every message being sent. Thus, now besides the height as the data of the message, we include an integer-valued timestamp. Moreover, we provide a correctness proof for the algorithm and specific type of situations in which a leader is not elected unnecessarily.

Leader election has been extensively studied, both forstatic and dynamic networks, the latter category including mobile networks. Here we mention some representative papers on leader election in dynamic networks. Hatzis et al. [9] presented algorithms for leader election in mobile networks in which nodes are expected to control their movement in order to facilitate communication. This type of algorithm is not suitable for networks in which nodes can move arbitrarily. Vasudevan et al. [23] and Masum et al. [15] developed leader election algorithms for mobile networks with the goal of electing as leader the node with the highest priority according to some criterion. Both these algorithms are designed for the broadcast model. In contrast, our algorithm can elect any node as the leader, involves fewer types of messages than either of these two algorithms, and uses point-to-point communication rather than broad- casting. Brunekreef et al. [2] devised a leader election algorithm for a 1-hop wireless environment in which nodes can crash and recover. Our algorithm is suited to an arbitrary communication topology.

Several other leader election algorithms have been developed based on MANET routing algorithms. The algorithm in [18] is based on the Zone Routing Protocol [7]. A correctness proof is given, but only for the synchronous case assuming only one topology change. In [4], Derhab and Badache present a leader election algorithm for ad hoc wireless networks that, like ours, is based on the algorithms presented by Malpani et al. [13]. Our algorithm is simpler and uses fewer message types and smaller messages than the al- gorithm presented by Derhab and Badache. Unlike Derhab and Badache, we prove our algorithm is correct even when communication is asynchronous and multiple link changes and network partitions occur during the leader election process.

Dagdeviren et al. [3] and Rahman et al. [19] have recently proposed leader election algorithms for mobile ad hoc networks; these algorithms have been evaluated solely through simulation, and lack correctness proofs. A different direction is randomized leader election algorithms for wireless networks (e.g., [1]); our algorithm is deterministic.

Fault-tolerant leader election algorithms have been proposed for wired networks. Representative examples are Mans and Santoro’s algorithm for loop graphs subject to permanent link failures [14], Singh’s algorithm for complete graphs subject to intermittent link failures [20], and Pan and Singh’s algorithm [16] and Stoller’s algorithm [21] that tolerate node crashes.